<p>转载csdn</p> 
<p>1． 关于动态加载机制?? <br> 学习Java比C++更容易理解OOP的思想，毕竟C++还混合了不少面向过程的成分。很多人都能背出来Java语言的特点，所谓的动态加载机制等等。当然概念往往是先记住而后消化的，可有多少人真正去体会过动态加载的机制，试图去寻找过其中的细节呢?&nbsp; 提供大家一个方法： <br> 在命令行窗口运行Java程序的时候，加上这个很有用的参数： <br><br> java&nbsp; -verbose&nbsp; *.class <br><br> 这样会清晰的打印出被加载的类文件，大部分是jdk自身运行需要的，最后几行会明显的看到自己用到的那几个类文件被加载进来的顺序。即使你声明了一个类对象，不实例化也不会加载，说明只有真正用到那个类的实例即对象的时候，才会执行加载。这样是不是大家稍微能明白一点动态加载了呢？^_^ <br><br> 2． 关于寻找class文件原理?? <br> 建议大家在入门的时候在命令行窗口编译和运行，不要借助JCreator或者Eclipse等IDE去帮助做那些事情。尝试自己这样做： <br> javac&nbsp; &nbsp; -classpath&nbsp; yourpath&nbsp; *.java <br> java&nbsp; &nbsp; -classpath&nbsp; yourpath&nbsp; *.class <br> 也许很多人都能看懂，设置classpath的目的就是告诉编译器去哪里寻找你的class文件.&nbsp; 不过至少笔者今日才弄懂JVM去查询类的原理，编译器加载类要依靠classloader，&nbsp; 而classloader有3个级别，从高到低分别是BootClassLoader(名字可能不准确)&nbsp; ,&nbsp; ExtClassLoader,&nbsp; AppClassLoader. <br><br> 这3个加载器分别对应着编译器去寻找类文件的优先级别和不同的路径：BootClassLoader对应jre/classes路径，是编译器最优先寻找class的地方 <br> ExtClassLoader对应jre/lib/ext路径，是编译器次优先寻找class的地方 <br> AppClassLoader对应当前路径，所以也是编译器默认找class的地方 <br><br> 其实大家可以自己写个程序简单的测试，对任何class，例如A,&nbsp; <br> 调用new&nbsp; A().getClass().getClassLoader().toString()&nbsp; 打印出来就可以看到，把class文件放在不同的路径下再次执行，就会看到区别。特别注意的是如果打印出来是null就表示到了最高级 BootClassLoader,&nbsp; 因为它是C++编写的，不存在Java对应的类加载器的名字。 <br><br> 寻找的顺序是一种向上迂回的思想，即如果本级别找不到，就只能去本级别之上的找，不会向下寻找。不过似乎从Jdk1.4到Jdk1.6这一特点又有改变，没有找到详细资料。所以就不举例子了。告诉大家设计这种体系的是Sun公司曾经的技术核心宫力先生，一个纯种华人哦！^_^ <br><br> 这样希望大家不至于迷惑为什么总报错找不到类文件，不管是自己写的还是导入的第三方的jar文件（J2ee中经常需要导入的）。 <br><br> 3． 关于jdk和jre?? <br> 大家肯定在安装JDK的时候会有选择是否安装单独的jre，一般都会一起安装，我也建议大家这样做。因为这样更能帮助大家弄清楚它们的区别： <br><br> Jre&nbsp; 是java&nbsp; runtime&nbsp; environment,&nbsp; 是java程序的运行环境。既然是运行，当然要包含jvm，也就是大家熟悉的虚拟机啦，&nbsp; 还有所有java类库的class文件，都在lib目录下打包成了jar。大家可以自己验证。至于在windows上的虚拟机是哪个文件呢？&nbsp; 学过MFC的都知道什么是dll文件吧，那么大家看看jre/bin/client里面是不是有一个jvm.dll呢？那就是虚拟机。 <br><br> Jdk&nbsp; 是java&nbsp; development&nbsp; kit，是java的开发工具包，里面包含了各种类库和工具。当然也包括了另外一个Jre.&nbsp; &nbsp; 那么为什么要包括另外一个Jre呢？而且jdk/jre/bin同时有client和server两个文件夹下都包含一个jvm.dll。&nbsp; 说明是有两个虚拟机的。这一点不知道大家是否注意到了呢？ <br><br> 相信大家都知道jdk的bin下有各种java程序需要用到的命令，与jre的bin目录最明显的区别就是jdk下才有javac，这一点很好理解，因为 jre只是一个运行环境而已。与开发无关，正因为如此，具备开发功能的jdk自己的jre下才会同时有client性质的jvm和server性质的 jvm，&nbsp; 而仅仅作为运行环境的jre下只需要client性质的jvm.dll就够了。 <br><br> 记得在环境变量path中设置jdk/bin路径麽？这应该是大家学习Java的第一步吧，&nbsp; 老师会告诉大家不设置的话javac和java是用不了的。确实jdk/bin目录下包含了所有的命令。可是有没有人想过我们用的java命令并不是 jdk/bin目录下的而是jre/bin目录下的呢？不信可以做一个实验，大家可以把jdk/bin目录下的java.exe剪切到别的地方再运行 java程序，发现了什么？一切OK！ <br><br> 那么有人会问了？我明明没有设置jre/bin目录到环境变量中啊？ <br><br> 试想一下如果java为了提供给大多数人使用，他们是不需要jdk做开发的，只需要jre能让java程序跑起来就可以了，那么每个客户还需要手动去设置环境变量多麻烦啊？所以安装jre的时候安装程序自动帮你把jre的java.exe添加到了系统变量中，验证的方法很简单，大家看到了系统环境变量的 path最前面有“%SystemRoot%\system32;%SystemRoot%;”这样的配置，那么再去Windows/system32下面去看看吧，发现了什么？有一个java.exe。 <br><br> 如果强行能够把jdk/bin挪到system32变量前面，当然也可以迫使使用jdk/jre里面的java，不过除非有必要，我不建议大家这么做。使用单独的jre跑java程序也算是客户环境下的一种测试。 <br><br> 这下大家应该更清楚jdk和jre内部的一些联系和区别了吧？ <br><br> PS:&nbsp; 其实还有满多感想可以总结的，一次写多了怕大家扔砖头砸死我，怪我太罗唆。大家应该更加踏实更加务实的去做一些研究并互相分享心得，大方向和太前沿的技术讨论是必要的但最好不要太多，毕竟自己基础都还没打好，什么都讲最新版本其实是进步的一大障碍！</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>Java&nbsp; 学习杂谈（二） <br> 鉴于上回写的一点感想大家不嫌弃，都鼓励小弟继续写下去，好不容易等到国庆黄金周，实习总算有一个休息的阶段，于是这就开始写第二篇了。希望这次写的仍然对志同道合的朋友们有所帮助。上回讲了Java动态加载机制、classLoader原理和关于jdk和jre三个问题。这次延续着讲一些具体的类库?? <br><br> 1．&nbsp; 关于集合框架类 <br> 相信学过Java的各位对这个名词并不陌生，对&nbsp; java.util.*这个package肯定也不陌生。不知道大家查询API的时候怎么去审视或者分析其中的一个package，每个包最重要的两个部分就是interfaces和classes，接口代表了它能做什么，实现类则代表了它如何去做。关注实现类之前，我们应该先理解清楚它的来源接口，不管在j2se还是j2ee中，都应该是这样。那么我们先看这三个接口：List、Set、Map。 <br> 也许有些人不太熟悉这三个名字，但相信大部分人都熟悉ArrayList，LinkedList，TreeSet，HashSet，HashMap，&nbsp; &nbsp; Hashtable等实现类的名字。它们的区别也是满容易理解的，List放可以重复的对象集合，Set放不可重复的对象组合，而Map则放&nbsp; &lt;Key,Value&nbsp; &gt; 这样的名值对，&nbsp; Key不可重复，Value可以。这里有几个容易混淆的问题： <br><br> 到底Vector和ArrayList，Hashtable和HashMap有什么区别？ <br> 很多面试官喜欢问这个问题，其实更专业一点应该这样问：新集合框架和旧集合框架有哪些区别？新集合框架大家可以在这些包中找since&nbsp; jdk1.2的，之前的如vector和Hashtable都是旧的集合框架包括的类。那么区别是？ <br> a.&nbsp; 新集合框架的命名更加科学合理。例如List下的ArrayList和LinkedList <br> b.&nbsp; 新集合框架下全部都是非线程安全的。建议去jdk里面包含的源代码里面自己去亲自看看vector和ArrayList的区别吧。当然如果是jdk5.0之后的会比较难看一点，因为又加入了泛型的语法，类似c++的template语法。 <br><br> 那么大家是否想过为什么要从旧集合框架默认全部加锁防止多线程访问更新到新集合框架全部取消锁，默认方式支持多线程？(当然需要的时候可以使用collections的静态方法加锁达到线程安全) <br> 笔者的观点是任何技术的发展都未必是遵循它们的初衷的，很多重大改变是受到客观环境的影响的。大家知道Java的初衷是为什么而开发的麽？是为嵌入式程序开发的。记得上一篇讲到classLoader机制麽？那正是为了节约嵌入式开发环境下内存而设计的。而走到今天，Java成了人们心中为互联网诞生的语言。互联网意味着什么？多线程是必然的趋势。客观环境在变，Java技术也随着飞速发展，导致越来越脱离它的初衷。据说Sun公司其实主打的是J2se，结果又是由于客观环境影响，J2se几乎遗忘，留在大家谈论焦点的一直是j2ee。 <br><br> 技术的细节这里就不多说了，只有用了才能真正理解。解释这些正是为了帮助大家理解正在学的和将要学的任何技术。之后讲j2ee的时候还会再讨论。 <br> 多扯句题外话：几十年前的IT巨人是IBM，Mainframe市场无人可比。微软如何打败IBM？正是由于硬件飞速发展，对个人PC的需求这个客观环境，让微软通过OS称为了第二个巨人。下一个打败微软的呢？Google。如何做到的？如果微软并不和IBM争大型机，Google借着互联网飞速发展这个客观环境作为决定性因素，避开跟微软争OS，而是走搜索引擎这条路，称为第3个巨人。那么第4个巨人是谁呢？很多专家预言将在亚洲或者中国出现，&nbsp; Whatever，客观环境变化趋势才是决定大方向的关键。当然笔者也希望会出现在中国，^_^~~ <br><br> 2．&nbsp; 关于Java设计模式 <br> 身边的很多在看GOF的23种设计模式，似乎学习它无论在学校还是在职场，都成了一种流行风气。我不想列举解释这23种Design&nbsp; Pattern，&nbsp; 我写这些的初衷一直都是谈自己的经历和看法，希望能帮助大家理解。 <br> 首先我觉得设计模式只是对一类问题的一种通用解决办法，只要是面向对象的编程预言都可以用得上这23种。理解它们最好的方法就是亲自去写每一种，哪怕是一个简单的应用就足够了。如果代码实现也记不住的话，记忆它们对应的UML图会是一个比较好的办法，当然前提是必须了解UML。 <br> 同时最好能利用Java自身的类库帮助记忆，例如比较常用的观察者模式，在java.util.*有现成的Observer接口和Observable这个实现类，看看源代码相信就足够理解观察者模式了。再比如装饰器模式，大家只要写几个关于java.io.*的程序就可以完全理解什么是装饰器模式了。有很多人觉得刚入门的时候不该接触设计模式，比如图灵设计丛书系列很出名的那本《Java设计模式》，作者:&nbsp; Steven&nbsp; John&nbsp; Metsker，大部分例子老实说令现在的我也很迷惑。但我仍然不同意入门跟学习设计模式有任何冲突，只是我们需要知道每种模式的概念的和典型的应用，这样我们在第一次编写&nbsp; FileOutputStream、BufferedReader、PrintWriter的时候就能感觉到原来设计模式离我们如此之近，而且并不是多么神秘的东西。 <br><br> 另外，在学习某些模式的同时，反而更能帮助我们理解java类库的某些特点。例如当你编写原型(Prototype)模式的时候，你必须了解的是&nbsp; java.lang.Cloneable这个接口和所有类的基类Object的clone()这个方法。即深copy和浅copy的区别： <br> Object.clone()默认实现的是浅copy，也就是复制一份对象拷贝，但如果对象包含其他对象的引用，不会复制引用，所以原对象和拷贝共用那个引用的对象。 <br> 深copy当然就是包括对象的引用都一起复制啦。这样原对象和拷贝对象，都分别拥有一份引用对象。如果要实现深copy就必须首先实现&nbsp; java.lang.Cloneable接口，然后重写clone()方法。因为在Object中的clone()方法是protected签名的，而&nbsp; Cloneable接口的作用就是把protected放大到public，这样clone()才能被重写。 <br><br> 那么又有个问题了？如果引用的对象又引用了其他对象呢？这样一直判断并复制下去，是不是显得很麻烦？曾经有位前辈告诉我的方法是重写clone方法的时候直接把原对象序列化到磁盘上再反序列化回来，这样不用判断就可以得到一个深copy的结果。如果大家不了解序列化的作法建议看一看&nbsp; ObjectOutputStream和ObjectInputStream <br><br> 归根结底，模式只是思想上的东西，把它当成前人总结的经验其实一点都不为过。鼓励大家动手自己去写，例如代理模式，可以简单的写一个Child类，&nbsp; Adult类。Child要买任何东西由Adult来代理实现。简单来说就是Adult里的buy()内部实际调用的是Child的buy()，可是暴露在main函数的却是Adult.buy()。这样一个简单的程序就足够理解代理模式的基本含义了。&nbsp; <br> ################################################################################################################</p> 
<p>&nbsp;</p> 
<p>Java&nbsp; 杂谈（三） <br> &nbsp; &nbsp; &nbsp; &nbsp; 这已经笔者写的第三篇Java杂记了，庆幸前两篇一直得到论坛朋友们的支持鼓励，还望大家继续指正不足之处。笔者也一直渴望通过这样方式清醒的自审，来寻找自己技术上的不足之处，希望和共同爱好Java的同仁们一起提高。 <br> &nbsp; &nbsp; &nbsp; &nbsp; 前两次分别讲述了关于jvm、jdk、jre、collection、classLoader和一些Design&nbsp; Pattern的自我理解。这次仍然不准备开始过渡到j2ee中，因为觉得还有一些琐碎的j2se的问题没有总结完毕。 <br> &nbsp; &nbsp; <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1．&nbsp; 关于Object类理解 <br> &nbsp; &nbsp; &nbsp; &nbsp; 大家都知道Object是所有Java类的基类，&nbsp; 意味着所有的Java类都会继承了Object的11个方法。建议大家去看看Object的&nbsp; 11个成员函数的源代码，就会知道默认的实现方式。比如equals方法，默认实现就是用"=="来比较，即直接比较内存地址，返回true&nbsp; 或者&nbsp; false。而toString()方法，返回的串组成方式是?? <br> &nbsp; &nbsp; &nbsp; &nbsp; "getClass().getName()&nbsp; +&nbsp; "@"&nbsp; +&nbsp; Integer.toHexString(hashCode())" <br> &nbsp; &nbsp; &nbsp; &nbsp; 其实不用我过多的解释，大家都能看懂这个串的组成。接下来再看看hashCode()： <br> &nbsp; &nbsp; &nbsp; &nbsp; public&nbsp; native&nbsp; int&nbsp; hashCode()； <br> &nbsp; &nbsp; &nbsp; <br> &nbsp; &nbsp; &nbsp; &nbsp; 由于是native方法，跟OS的处理方式相关，源代码里仅仅有一个声明罢了。我们有兴趣的话完全可以去深究它的hashCode到底是由OS怎么样产生的呢？但笔者建议最重要的还是先记住使用它的几条原则吧！首先如果equals()方法相同的对象具有相通的hashCode，但equals&nbsp; ()对象不相通的时候并不保证hashCode()方法返回不同的整数。而且下一次运行同一个程序，同一个对象未必还是当初的那个hashCode()&nbsp; 哦。 <br> &nbsp; &nbsp; &nbsp; &nbsp; 其余的方法呢？nofigy()、notifyAll()、clone()、wait()都是native方法的，说明依赖于操作系统的实现。最后一个有趣的方法是finalize()，类似C++的析构函数，签名是protected，证明只有继承扩展了才能使用，方法体是空的，默示什么也不做。它的作用据笔者的了解仅仅是通知JVM此对象不再使用，随时可以被销毁，而实际的销毁权还是在于虚拟机手上。那么它真的什么也不做麽？未必，实际上如果是线程对象它会导致在一定范围内该线程的优先级别提高，导致更快的被销毁来节约内存提高性能。其实从常理来说，我们也可以大概这样猜测出jvm做法的目的。 <br><br> &nbsp; &nbsp; &nbsp; &nbsp; 2．&nbsp; 关于重载hashCode()与Collection框架的关系 <br> 笔者曾经听一位搞Java培训多年的前辈说在他看来hashCode方法没有任何意义，仅仅是为了配合证明具有同样的hashCode会导致equals&nbsp; 方法相等而存在的。连有的前辈都犯这样的错误，其实说明它还是满容易被忽略的。那么hashCode()方法到底做什么用？ <br> &nbsp; &nbsp; &nbsp; <br> &nbsp; &nbsp; &nbsp; &nbsp; 学过数据结构的课程大家都会知道有一种结构叫hash&nbsp; table，目的是通过给每个对象分配一个唯一的索引来提高查询的效率。那么Java也不会肆意扭曲改变这个概念，所以hashCode唯一的作用就是为支持数据结构中的哈希表结构而存在的，换句话说，也就是只有用到集合框架的&nbsp; Hashtable、HashMap、HashSet的时候，才需要重载hashCode()方法， <br> 这样才能使得我们能人为的去控制在哈希结构中索引是否相等。笔者举一个例子： <br> &nbsp; &nbsp; &nbsp; &nbsp; 曾经为了写一个求解类程序，需要随机列出1,2,3,4组成的不同排列组合，所以笔者写了一个数组类用int[]来存组合结果，然后把随机产生的组合加入一个HashSet中，就是想利用HashSet不包括重复元素的特点。可是HashSet怎么判断是不是重复的元素呢？当然是通过&nbsp; hashCode()返回的结果是否相等来判断啦，可做一下这个实验： <br> &nbsp; &nbsp; &nbsp; &nbsp; int[]&nbsp; A&nbsp; =&nbsp; {1,2,3,4}; <br> &nbsp; &nbsp; &nbsp; &nbsp; int[]&nbsp; B&nbsp; =&nbsp; {1,2,3,4}; <br> &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(A.hashCode()); <br> &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(B.hashCode()); <br><br> &nbsp; &nbsp; &nbsp; &nbsp; 这明明是同一种组合，却是不同的hashCode，加入Set的时候会被当成不同的对象。这个时候我们就需要自己来重写hashCode()方法了，如何写呢？其实也是基于原始的hashCode()，毕竟那是操作系统的实现，&nbsp; 找到相通对象唯一的标识，实现方式很多，笔者的实现方式是： <br> &nbsp; &nbsp; &nbsp; &nbsp; 首先重写了toString()方法: <br> &nbsp; &nbsp; &nbsp; &nbsp; return&nbsp; &nbsp; A[0]“+”&nbsp; A[1]“+”&nbsp; A[2]“+”&nbsp; A[3];&nbsp; //显示上比较直观 <br> &nbsp; &nbsp; &nbsp; &nbsp; 然后利用toString()来计算hashCode()： <br> &nbsp; &nbsp; &nbsp; &nbsp; return&nbsp; &nbsp; this.toString().hashCode()； <br> &nbsp; &nbsp; &nbsp; &nbsp; 这样上述A和B返回的就都是”1234”，在测试toString().hashCode()，由于String在内存中的副本是一样的，”1234”.hashCode()返回的一定是相同的结果。 <br><br> &nbsp; &nbsp; &nbsp; &nbsp; 说到这，相信大家能理解得比我更好，今后千万不要再误解hashCode()方法的作用。 <br><br> &nbsp; &nbsp; &nbsp; &nbsp; 3．&nbsp; 关于Class类的成员函数与Java反射机制 <br> &nbsp; &nbsp; &nbsp; &nbsp; 很早刚接触Java就听很多老师说过Java的动态运行时机制、反射机制等。确实它们都是Java的显著特点，运行时加载笔者在第一篇介绍过了，现在想讲讲反射机制。在Java中，主要是通过java.lang包中的Class类和Method类来实现内存反射机制的。 <br> &nbsp; &nbsp; &nbsp; &nbsp; 熟悉C++的人一定知道下面这样在C++中是做不到的：&nbsp; 运行时以字符串参数传递一个类名，就可以得到这个类的所有信息，包括它所有的方法，和方法的详细信息。还可以实例化一个对象，并通过查到的方法名来调用该对象的任何方法。这是因为Java的类在内存中除了C++中也有的静态动态数据区之外，还包括一份对类自身的描述，也正是通过这描述中的信息，才能帮助我们才运行时读取里面的内容，得到需要加载目标类的所有信息，从而实现反射机制。大家有没有想过当我们需要得到一个JavaBean的实例的时候，怎么知道它有哪些属性呢？再明显简单不过的例子就是自己写一个JavaBean的解析器： <br><br> &nbsp; &nbsp; &nbsp; &nbsp; a.&nbsp; 通过Class.forName(“Bean的类名”)得到Class对象，例如叫ABeanClass <br> &nbsp; &nbsp; &nbsp; &nbsp; b.&nbsp; 通过ABeanClass的getMethods()方法，得到Method[]对象 <br> &nbsp; &nbsp; &nbsp; &nbsp; c.&nbsp; 按照规范所有get方法名后的单词就代表着该Bean的一个属性 <br> &nbsp; &nbsp; &nbsp; &nbsp; d.&nbsp; 当已经知道一个方法名，可以调用newInstance()得到一个实例，然后通过invoke()方法将方法的名字和方法需要用的参数传递进去，就可以动态调用此方法。 <br><br> &nbsp; &nbsp; &nbsp; &nbsp; 当然还有更复杂的应用，这里就不赘述，大家可以参考Class类和Method类的方法。 <br><br> &nbsp; &nbsp; &nbsp; &nbsp; 4．&nbsp; 坦言Synchronize的本质 <br> &nbsp; &nbsp; &nbsp; &nbsp; Synchronize大家都知道是同步、加锁的意思，其实它的本质远没有大家想得那么复杂。声明Synchronize的方法被调用的时候，锁其实是加载对象上，当然如果是静态类则是加在类上的锁，调用结束锁被解除。它的实现原理很简单，仅仅是不让第二把锁再次被加在同一个对象或类上，仅此而已。一个简单的例子足以说明问题： <br> &nbsp; &nbsp; &nbsp; &nbsp; class&nbsp; A{ <br> synchronized&nbsp; void&nbsp; f(){} <br> void&nbsp; g(){} <br> &nbsp; &nbsp; &nbsp; &nbsp; } <br><br> &nbsp; &nbsp; &nbsp; &nbsp; 当A的一个对象a被第一个线程调用其f()方法的时候，第二个线程不能调用a的synchronized方法例如f()，因为那是在试图在对象上加第二把锁。但调用g()却是可以的，因为并没有在同一对象上加两把锁的行为产生。 <br> &nbsp; &nbsp; &nbsp; &nbsp; 这样大家能理解了麽？明白它的原理能更好的帮助大家设计同步机制，不要滥用加锁。 <br><br> &nbsp; &nbsp; &nbsp; &nbsp; PS：下篇笔者计划开始对J2ee接触到的各个方面来进行总结，谈谈自己的经验和想法。希望大家还能一如既往的支持笔者写下去，指正不足之处。 <br> ############################################################################################################# </p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>Java杂谈（四） <br><br> &nbsp; &nbsp; &nbsp; &nbsp; 不知不觉已经写到第四篇了，论坛里面不断的有朋友鼓励我写下去。坚持自己的作风，把一切迷惑不容易理清楚的知识讲出来，讲到大家都能听懂，那么自己就真的懂了。最近在公司实习的时候Trainer跟我讲了很多经典事迹，对还未毕业的我来说是笔不小的财富，我自己的信念是：人在逆境中成长的速度要远远快过顺境中，这样来看一切都能欣然接受了。 <br> &nbsp; &nbsp; &nbsp; &nbsp; 好了，闲话不说了，第三篇讲的是反射机制集合框架之类的，这次打算讲讲自己对反序列化和多线程的理解。希望能对大家学习Java起到帮助?? <br> &nbsp; &nbsp; &nbsp; <br> &nbsp; &nbsp; &nbsp; &nbsp; 1．关于序列化和反序列化 <br> &nbsp; &nbsp; &nbsp; &nbsp; 应该大家都大概知道Java中序列化和反序列化的意思，序列化就是把一个Java对象转换成二进制进行磁盘上传输或者网络流的传输，反序列化的意思就是把这个接受到的二进制流重新组装成原来的对象逆过程。它们在Java中分别是通过ObjectInputStream和&nbsp; ObjectOutStream这两个类来实现的（以下分别用ois和oos来简称）。 <br> &nbsp; &nbsp; &nbsp; <br> &nbsp; &nbsp; &nbsp; &nbsp; oos的writeObject()方法用来执行序列化的过程，ois的readObject()用来执行反序列化的过程，在传输二进制流之前，需要讲这两个高层流对象连接到同一个Channel上，这个Channel可以是磁盘文件，也可以是socket底层流。所以无论用哪种方式，底层流对象都是以构造函数参数的形式传递进oos和ois这两个高层流，连接完毕了才可以进行二进制数据传输的。例子： <br> &nbsp; &nbsp; &nbsp; &nbsp; 可以是文件流通道 <br> &nbsp; &nbsp; &nbsp; &nbsp; file&nbsp; =&nbsp; new&nbsp; File(“C:/data.dat”); <br> &nbsp; &nbsp; &nbsp; &nbsp; oos&nbsp; =&nbsp; new&nbsp; ObjectOutputStream(new&nbsp; FileOutputStream(file)); <br> &nbsp; &nbsp; &nbsp; &nbsp; ois&nbsp; =&nbsp; new&nbsp; ObjectInputStream(new&nbsp; FileInputStream(file)); <br> &nbsp; &nbsp; &nbsp; <br> &nbsp; &nbsp; &nbsp; &nbsp; 或者网络流通道 <br> &nbsp; &nbsp; &nbsp; &nbsp; oos&nbsp; =&nbsp; new&nbsp; ObjectOutputStream(socket.getOutputStream()); <br> &nbsp; &nbsp; &nbsp; &nbsp; ois&nbsp; =&nbsp; new&nbsp; ObjectInputStream(socket.getInputStream());&nbsp; <br><br> &nbsp; &nbsp; &nbsp; &nbsp; 不知道大家是否注意到oos总是在ois之前定义，这里不希望大家误解这个顺序是固定的么？回答是否定的，那么有顺序要求么？回答是肯定的。原则是什么呢？ <br> 原则是互相对接的输入/输出流之间必须是output流先初始化然后再input流初始化，否则就会抛异常。大家肯定会问为什么？只要稍微看一看这两个类的源代码文件就大概知道了，output流的任务很简单，只要把对象转换成二进制往通道中写就可以了，但input流需要做很多准备工作来接受并最终重组这个Object，所以ObjectInputStream的构造函数中就需要用到output初始化发送过来的header信息，这个方法叫做&nbsp; readStreamHeader()，它将会去读两个Short值用于决定用多大的缓存来存放通道发送过来的二进制流，这个缓存的size因jre的版本不同是不一样的。所以output如果不先初始化，input的构造函数首先就无法正确运行。 <br> &nbsp; &nbsp; &nbsp; <br> &nbsp; &nbsp; &nbsp; &nbsp; 对于上面两个例子，第一个顺序是严格的，第二个因为oos和ois连接的已经不是对方了，而是socket另外一端的流，需要严格按照另外一方对接的output流先于对接的input流打开才能顺利运行。 <br> &nbsp; &nbsp; &nbsp; <br> &nbsp; &nbsp; &nbsp; &nbsp; 这个writeObject和readObject本身就是线程安全的，传输过程中是不允许被并发访问的。所以对象能一个一个接连不断的传过来，有很多人在运行的时候会碰到EOFException,&nbsp; 然后百思不得其解，去各种论坛问解决方案。其实笔者这里想说，这个异常不是必须声明的，也就是说它虽然是异常，但其实是正常运行结束的标志。EOF表示读到了文件尾，发送结束自然连接也就断开了。如果这影响到了你程序的正确性的话，请各位静下心来看看自己程序的业务逻辑，而不要把注意力狭隘的聚集在发送和接受的方法上。因为笔者也被这样的bug困扰了1整天，被很多论坛的帖子误解了很多次最后得出的教训。如果在while循环中去readObject，本质上是没有问题的，有对象数据来就会读，没有就自动阻塞。那么抛出EOFException一定是因为连接断了还在继续read，什么原因导致连接断了呢？一定是业务逻辑哪里存在错误，比如NullPoint、&nbsp; ClassCaseException、ArrayOutofBound，即使程序较大也没关系，最多只要单步调适一次就能很快发现bug并且解决它。 <br> &nbsp; &nbsp; &nbsp; <br> &nbsp; &nbsp; &nbsp; &nbsp; 难怪一位程序大师说过：解决问题90％靠经验，5％靠技术，剩下5％靠运气！真是金玉良言，笔者大概查阅过不下30篇讨论在while循环中使用&nbsp; readObject抛出EOFExceptionde&nbsp; 的帖子，大家都盲目的去关注解释这个名词、反序列化的行为或反对这样写而没有一个人认为EOF是正确的行为，它其实很老实的在做它的事情。为什么大家都忽略了真正出错误的地方呢？两个字，经验！ <br><br> &nbsp; &nbsp; &nbsp; &nbsp; 2．关于Java的多线程编程 <br> &nbsp; &nbsp; &nbsp; &nbsp; 关于Java的线程，初学或者接触不深的大概也能知道一些基本概念，同时又会很迷惑线程到底是怎么回事？如果有人认为自己已经懂了不妨来回答下面的问题： <br> &nbsp; &nbsp; &nbsp; &nbsp; a.&nbsp; A对象实现Runnable接口，A.start()运行后所谓的线程对象是谁？是A么？ <br> &nbsp; &nbsp; &nbsp; &nbsp; b.&nbsp; 线程的wait()、notify()方法到底是做什么时候用的，什么时候用？ <br> &nbsp; &nbsp; &nbsp; &nbsp; c.&nbsp; 为什么线程的suspend方法会被标注过时，不推荐再使用，线程还能挂起么？ <br> &nbsp; &nbsp; &nbsp; &nbsp; d.&nbsp; 为了同步我们会对线程方法声明Synchronized来加锁在对象上，那么如果父类的f()方法加了Synchronized，子类重写f()方法必须也加Synchronized么？如果子类的f()方法重写时声明Synchronized并调用super.f()，那么子类对象上到底有几把锁呢？会因为竞争产生死锁么？ <br><br> &nbsp; &nbsp; &nbsp; &nbsp; 呵呵，各位能回答上来几道呢？如果这些都能答上来，说明对线程的概念还是满清晰的，虽说还远远不能算精通。笔者这里一一做回答，碍于篇幅的原因，笔者尽量说得简介一点，如果大家有疑惑的欢迎一起讨论。 <br> &nbsp; &nbsp; &nbsp; <br> &nbsp; &nbsp; &nbsp; &nbsp; 首先第一点，线程跟对象完全是两回事，虽然我们也常说线程对象。但当你用run()和start()来启动一个线程之后，线程其实跟这个继承了&nbsp; Thread或实现了Runnable的对象已经没有关系了，对象只能算内存中可用资源而对象的方法只能算内存正文区可以执行的代码段而已。既然是资源和代码段，另外一个线程当然也可以去访问，main函数执行就至少会启动两个线程，一个我们称之为主线程，还一个是垃圾收集器的线程，主线程结束就意味着程序结束，可垃圾收集器线程很可能正在工作。 <br> &nbsp; &nbsp; &nbsp; <br> &nbsp; &nbsp; &nbsp; &nbsp; 第二点，wait()和sleep()类似，都是让线程处于阻塞状态暂停一段时间，不同之处在于wait会释放当前线程占有的所有的锁，而&nbsp; sleep不会。我们知道获得锁的唯一方法是进入了Synchronized保护代码段，所以大家会发现只有Synchronized方法中才会出现&nbsp; wait，直接写会给警告没有获得当前对象的锁。所以notify跟wait配合使用，notify会重新把锁还给阻塞的线程重而使其继续执行，当有多个对象wait了，notify不能确定唤醒哪一个，必经锁只有一把，所以一般用notifyAll()来让它们自己根据优先级等竞争那唯一的一把锁，竞争到的线程执行，其他线程只要继续wait。 <br><br> &nbsp; &nbsp; &nbsp; &nbsp; 从前Java允许在一个线程之外把线程挂起，即调用suspend方法，这样的操作是极不安全的。根据面向对象的思想每个对象必须对自己的行为负责，而对自己的权力进行封装。如果任何外步对象都能使线程被挂起而阻塞的话，程序往往会出现混乱导致崩溃，所以这样的方法自然是被毙掉了啦。 <br> &nbsp; &nbsp; &nbsp; <br> &nbsp; &nbsp; &nbsp; &nbsp; 最后一个问题比较有意思，首先回答的是子类重写f()方法可以加Synchronized也可以不加，如果加了而且还内部调用了super.f&nbsp; ()的话理论上是应该对同一对象加两把锁的，因为每次调用Synchronized方法都要加一把，调用子类的f首先就加了一把，进入方法内部调用父类的&nbsp; f又要加一把，加两把不是互斥的么？那么调父类f加锁不就必须永远等待已经加的锁释放而造成死锁么？实际上是不会的，这个机制叫重进入，当父类的f方法试图在本对象上再加一把锁的时候，因为当前线程拥有这个对象的锁，也可以理解为开启它的钥匙，所以同一个线程在同一对象上还没释放之前加第二次锁是不会出问题的，这个锁其实根本就没有加，它有了钥匙，不管加几把还是可以进入锁保护的代码段，畅通无阻，所以叫重进入，我们可以简单认为第二把锁没有加上去。 <br> &nbsp; &nbsp; &nbsp; <br> &nbsp; &nbsp; &nbsp; &nbsp; 总而言之，Synchronized的本质是不让其他线程在同一对象上再加一把锁。 <br> ######################################################################################################### <br> Java杂谈（五） <br><br><br> &nbsp; &nbsp; &nbsp; &nbsp; 本来预计J2se只讲了第四篇就收尾了，可是版主厚爱把帖子置顶长期让大家浏览让小弟倍感责任重大，务必追求最到更好，所以关于J2se一些没有提到的部分，决定再写几篇把常用的部分经验全部写出来供大家讨论切磋。这一篇准备讲一讲Xml解析包和Java&nbsp; Swing，然后下一篇再讲java.security包关于Java沙箱安全机制和RMI机制，再进入J2ee的部分，暂时就做这样的计划了。如果由于实习繁忙更新稍微慢了一些，希望各位见谅！&nbsp; <br><br> &nbsp; &nbsp; &nbsp; &nbsp; 1．&nbsp; Java关于XML的解析&nbsp; &nbsp; <br> &nbsp; &nbsp; &nbsp; &nbsp; 相信大家对XML都不陌生，含义是可扩展标记语言。本身它也就是一个数据的载体以树状表现形式出现。后来慢慢的数据变成了信息，区别是信息可以包括可变的状态从而针对程序硬编码的做法变革为针对统一接口硬编码而可变状态作为信息进入了XML中存储。这样改变状态实现扩展的唯一工作是在XML中添加一段文本信息就可以了，代码不需要改动也不需要重新编译。这个灵活性是XML诞生时候谁也没想到的。&nbsp; <br><br> &nbsp; &nbsp; &nbsp; &nbsp; 当然，如果接口要能提取XML中配置的信息就需要程序能解析规范的XML文件，Java中当然要提高包对这个行为进行有利支持。笔者打算讲到的两个包是 org.w3c.dom和javax.xml.parsers和。（大家可以浏览一下这些包中间的接口和类定义）&nbsp; <br> &nbsp; &nbsp; &nbsp; &nbsp; <br> &nbsp; &nbsp; &nbsp; &nbsp; Javax.xml.parsers包很简单，没有接口，两个工厂配两个解析器。显然解析XML是有两种方式的：DOM解析和SAX解析。本质上并没有谁好谁不好，只是实现的思想不一样罢了。给一个XML文件的例子：&nbsp; <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;?xml&nbsp; version=”1.0”&nbsp; encoding=”UTF-8”&nbsp; &gt;&nbsp; <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;root&nbsp; &gt;&nbsp; <br> &lt;child&nbsp; &nbsp; name=”Kitty”&nbsp; &gt;&nbsp; &nbsp; <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; A&nbsp; Cat&nbsp; &nbsp; <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;/child&nbsp; &gt;&nbsp; <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;/root&nbsp; &gt;&nbsp; <br> &nbsp; &nbsp; &nbsp; &nbsp; <br> &nbsp; &nbsp; &nbsp; &nbsp; 所谓DOM解析的思路是把整个树状图存入内存中，需要那个节点只需要在树上搜索就可以读到节点的属性，内容等，这样的好处是所有节点皆在内存可以反复搜索重复使用，缺点是需要消耗相应的内存空间。&nbsp; <br> &nbsp; &nbsp; &nbsp; &nbsp; <br> &nbsp; &nbsp; &nbsp; &nbsp; 自然SAX解析的思路就是为了克服DOM的缺点，以事件触发为基本思路，顺序的搜索下来，碰到了Element之前触发什么事件，碰到之后做什么动作。由于需要自己来写触发事件的处理方案，所以需要借助另外一个自定义的Handler，处于org.xml.sax.helpers包中。它的优点当然是不用整个包都读入内存，缺点也是只能顺序搜索，走完一遍就得重来。&nbsp; <br> &nbsp; &nbsp; &nbsp; &nbsp; <br> &nbsp; &nbsp; &nbsp; &nbsp; 大家很容易就能猜到，接触到的J2ee框架用的是哪一种，显然是DOM。因为类似Struts，Hibernate框架配置文件毕竟是很小的一部分配置信息，而且需要频繁搜索来读取，当然会采用DOM方式（其实SAX内部也是用DOM采用的结构来存储节点信息的）。现在无论用什么框架，还真难发现使用 SAX来解析XML的技术了，如果哪位仁兄知道，请让笔者也学习学习。&nbsp; <br><br> &nbsp; &nbsp; &nbsp; &nbsp; 既然解析方式有了，那么就需要有解析的存储位置。不知道大家是否发现org.w3c.dom这个包是没有实现类全部都是接口的。这里笔者想说一下Java 如何对XML解析是Jdk应该考虑的事，是它的责任。而w3c组织是维护定义XML标准的组织，所以一个XML结构是怎么样的由w3c说了算，它不关心 Java如何去实现，于是乎规定了所有XML存储的结构应该遵循的规则，这就是org.w3c.dom里全部的接口目的所在。在笔者看来，简单理解接口的概念就是实现者必须遵守的原则。&nbsp; <br><br> &nbsp; &nbsp; &nbsp; &nbsp; 整个XML对应的结构叫Document、子元素对应的叫做Element、还有节点相关的Node、NodeList、Text、Entity、 CharacterData、CDATASection等接口，它们都可以在XML的语法中间找到相对应的含义。由于这里不是讲解XML基本语法，就不多介绍了。如果大家感兴趣，笔者也可以专门写一篇关于XML的语法规则帖与大家分享一下。&nbsp; <br><br> &nbsp; &nbsp; &nbsp; &nbsp; 2．&nbsp; Java&nbsp; Swing&nbsp; <br> &nbsp; &nbsp; &nbsp; &nbsp; Swing是一个让人又爱又恨的东西，可爱之处在于上手很容易，较AWT比起来Swing提供的界面功能更加强大，可恨之处在于编复杂的界面工作量实在是巨大。笔者写过超过3000行的Swing界面，感觉用户体验还不是那么优秀。最近又写过超过6000行的，由于功能模块多了，整体效果还只是一般般。体会最深的就一个字：累!&nbsp; 所以大家现在都陆续不怎么用Swing在真正开发的项目上了，太多界面技术可以取代它了。笔者去写也是迫于无奈组里面大家都没写过，我不入地域谁入？&nbsp; <br> &nbsp; &nbsp; &nbsp; &nbsp; <br> &nbsp; &nbsp; &nbsp; &nbsp; 尽管Swing慢慢的在被人忽略，特别是随着B/S慢慢的在淹没C/S，笔者倒是很愿意站出来为Swing正身。每一项技术的掌握绝不是为了流行时尚跟风。真正喜欢Java的朋友们还是应该好好体会一下Swing，相信在校的很多学生也很多在学习它。很可能从Jdk&nbsp; 1.1、1.2走过来的很多大学老师可能是最不熟悉它的。&nbsp; <br> Swing提供了一组轻组件统称为JComponent，它们与AWT组件的最大区别是JComponent全部都是Container，而 Container的特点是里面可以装载别的组件。在Swing组件中无论是JButton、JLabel、JPanel、JList等都可以再装入任何其他组件。好处是程序员可以对Swing组件实现“再开发”，针对特定需求构建自己的按钮、标签、画板、列表之类的特定组件。&nbsp; <br><br> &nbsp; &nbsp; &nbsp; &nbsp; 有轻自然就有重，那么轻组件和重组件区别是？重组件表现出来的形态因操作系统不同而异，轻组件是Swing自己提供GUI，在跨平台的时候最大程度的保持一致。&nbsp; <br> 那么在编程的时候要注意一些什么呢？笔者谈谈自己的几点经验：&nbsp; <br><br> &nbsp; &nbsp; &nbsp; &nbsp; a.&nbsp; 明确一个概念，只有Frame组件才可以单独显示的，也许有人会说JOptionPane里面的静态方法就实现了单独窗口出现，但追寻源代码会发现其实现实出来的Dialog也需要依托一个Frame窗体，如果没有指定就会默认产生一个然后装载这个Dialog显示出来。&nbsp; <br><br> &nbsp; &nbsp; &nbsp; &nbsp; b.&nbsp; JFrame是由这么几部分组成：&nbsp; <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 最底下一层JRootPane，上面是glassPane&nbsp; (一个JPanel)和layeredPane&nbsp; (一个JLayeredPane)，而layeredPane又由contentPane(一个JPanel)和menuBar构成。我们的组件都是加在 contentPane上，而背景图片只能加在layeredPane上面。&nbsp; 至于glassPane是一个透明的覆盖了contentPane的一层，在特定效果中将被利用到来记录鼠标坐标或掩饰组件。&nbsp; <br><br> &nbsp; &nbsp; &nbsp; &nbsp; c.&nbsp; 为了增强用户体验，我们会在一些按钮上添加快捷键，但Swing里面通常只能识别键盘的Alt键，要加入其他的快捷键，必须自己实现一个ActionListener。&nbsp; <br><br> &nbsp; &nbsp; &nbsp; &nbsp; d.&nbsp; 通过setLayout(null)可以使得所有组件以setBounds()的四个参数来精确定位各自的大小、位置，但不推荐使用，因为好的编程风格不应该在Swing代码中硬编码具体数字，所有的数字应该以常数的形式统一存在一个静态无实例资源类文件中。这个静态无实例类统一负责Swing界面的风格，包括字体和颜色都应该包括进去。&nbsp; <br><br> &nbsp; &nbsp; &nbsp; &nbsp; e.&nbsp; 好的界面设计有一条Golden&nbsp; Rule:&nbsp; 用户不用任何手册通过少数尝试就能学会使用软件。所以尽量把按钮以菜单的形式（不管是右键菜单还是窗体自带顶部菜单）呈现给顾客，除非是频繁点击的按钮才有必要直接呈现在界面中。&nbsp; <br><br> &nbsp; &nbsp; &nbsp; &nbsp; 其实Swing的功能是相当强大的，只是现在应用不广泛，专门去研究大概是要花不少时间的。笔者在各网站论坛浏览关于Swing的技巧文章还是比较可信的，自己所学非常有限，各人体会对Swing各个组件的掌握就是一个实践积累的过程。笔者只用到过以上这些，所以只能谈谈部分想法，还望大家见谅！&nbsp; <br> ###################################################################################################################</p>