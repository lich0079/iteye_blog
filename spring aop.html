<p><br>spring对AOP的支持（采用Annotation的方式）<br>1、spring依赖库<br>&nbsp;* SPRING_HOME/dist/spring.jar<br>&nbsp;* SPRING_HOME/lib/commons-logging.jar<br>&nbsp;* SPRING_HOME/lib/log4j-1.2.14.jar<br>&nbsp;* SPRING_HOME/lib/*.jar<br>&nbsp;&nbsp;<br>2、模块化横切关注点，采用@Aspect定义切面</p> 
<p>3、在Aspect中定义Pointcut和Advice</p> 
<p>4、启用AspectJ对Annotation的支持，参见applicationContext.xml</p> 
<p>注意：采用Annotation定义Pointcut,Pointcut的方法是不被执行的，它存在的目的<br>&nbsp;&nbsp;&nbsp;&nbsp; 仅仅是为了Adivce重用Pointcut的定义<br>&nbsp;&nbsp;&nbsp;&nbsp; <br>AOP中的术语：<br>&nbsp;* Cross cutting concern<br>&nbsp;* Aspect<br>&nbsp;* Advice<br>&nbsp;* Pointcut<br>&nbsp;* Jointpoint<br>&nbsp;* Weave<br>&nbsp;* target Object<br>&nbsp;* Proxy<br>&nbsp;* Introduction</p> 
<p><br>public class Client {</p> 
<p>&nbsp;public static void main(String[] args) {<br>&nbsp;&nbsp;<br>&nbsp;&nbsp;BeanFactory factory = new ClassPathXmlApplicationContext("applicationContext.xml");<br>&nbsp;&nbsp;//必须是接口实现<br>&nbsp;&nbsp;UserManager userManager = (UserManager)factory.getBean("userManager");<br>&nbsp;&nbsp;//UserManagerImpl userManager = (UserManagerImpl)factory.getBean("userManager");<br>&nbsp;&nbsp;userManager.addUser("Tom", "123");</p> 
<p>&nbsp;}<br>}</p> 
<p><br>&lt;aop:aspectj-autoproxy/&gt;&nbsp; <br>&nbsp;<br>&nbsp;&lt;bean id="securityHandler" class="com.bjsxt.spring.SecurityHandler"/&gt;<br>&nbsp;<br>&nbsp;&lt;bean id="userManager" class="com.bjsxt.spring.UserManagerImpl"/&gt;</p> 
<p><br>@Aspect<br>public class SecurityHandler {<br>&nbsp;<br>&nbsp;/**<br>&nbsp; * 定义Pointcut，Pointcut的名是allAddMethod,不能有返回值，该方法只是一个标识<br>&nbsp; * Pointcut内容是一个表达式，来描述织入到哪些对象上的哪些方法(订阅感兴趣Joinpoint)<br>&nbsp; */<br>&nbsp;@Pointcut("execution(* add*(..))")<br>&nbsp;private void allAddMethod(){}<br>&nbsp;<br>&nbsp;/**<br>&nbsp; * 定义Advice，标识在目标对象上的哪些方法织入Advice<br>&nbsp; */<br>&nbsp;@Before("allAddMethod()")<br>&nbsp;private void checkSecurity() {<br>&nbsp;&nbsp;System.out.println("-----checkSecurity-------");<br>&nbsp;}</p> 
<p>}<br>&nbsp;<br>----------------------------<br>spring对AOP的支持（采用静态配置文件的方式）<br>1、spring依赖库<br>&nbsp;* SPRING_HOME/dist/spring.jar<br>&nbsp;* SPRING_HOME/lib/commons-logging.jar<br>&nbsp;* SPRING_HOME/lib/log4j-1.2.14.jar<br>&nbsp;* SPRING_HOME/lib/*.jar<br>&nbsp;<br>2、配置方法<br>&nbsp;&lt;aop:config&gt;<br>&nbsp;&nbsp;&lt;aop:aspect id="securityAspect" ref="securityHandler"&gt;<br>&nbsp;&nbsp;&nbsp;&lt;aop:pointcut id="allAddMethod" expression="execution(* com.bjsxt.spring.*.add*(..)) || execution(* com.bjsxt.spring.*.del*(..))"/&gt;<br>&nbsp;&nbsp;&nbsp;&lt;aop:before pointcut-ref="allAddMethod" method="checkSecurity"/&gt;<br>&nbsp;&nbsp;&lt;/aop:aspect&gt;<br>&nbsp;&lt;/aop:config&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;<br>--------------------------------<br>spring对AOP的支持</p> 
<p>Aspect类默认情况下不需要实现接口，但是对于目标对象（UserManagerImpl.java）,默认情况下<br>必须实现接口，如果没有实现接口必须使用CGLIB库实现代理</p> 
<p>我们可以通过在Advice中添加一个JoinPoint参数，这只值是spring自动传入的，从JoinPoint中<br>我们可以得到相关的参数值，方法名等等</p> 
<p><br>-------------------------<br>spring对AOP的支持</p> 
<p>1、如果目标对象实现了接口，默认会采用JDK的动态代理机制实现AOP<br>2、如果目标对象实现了接口，可以强制使用CGLIB实现AOP<br>3、如果目标对象没有实现接口，必须使用CGLIB生成代理，spring会自动在CGLIB和JDK动态代理之间切换</p> 
<p>如何强制使用CGLIB生成代理？<br>&nbsp;* 添加CGLIB库，SPRING_HOME/lib/cglib/*.jar<br>&nbsp;* 在spring的配置文件中加入：<br>&nbsp;&lt;aop:aspectj-autoproxy proxy-target-class="true"/&gt;</p> 
<p>JDK代理和CGLIB代理的区别？<br>&nbsp;* JDK代理只能对实现了接口的类生成代理，而不能针对类<br>&nbsp;* CGLIB是针对类实现代理的，主要对指定的类生成一个子类，并覆盖其中的方法，<br>&nbsp;&nbsp; 因为是继承，所以不能使用final来修饰类或方法<br>---</p>