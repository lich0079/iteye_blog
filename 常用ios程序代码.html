<p>&nbsp;</p> 
<p>我的原文在evernote，evernote链接的内容会不断更新</p> 
<p><a href="http://www.evernote.com/shard/s20/sh/9c35c399-4f7c-4015-944c-ad055cb547db/ba84af5872b716b59f18944a9a5e41a2">http://www.evernote.com/shard/s20/sh/9c35c399-4f7c-4015-944c-ad055cb547db/ba84af5872b716b59f18944a9a5e41a2</a> </p> 
<p>&nbsp;</p> 
<p><span style="color: #01010a;"><span style="font-family: Arial,sans-serif,Helvetica,Tahoma;">Settings 设置问题<br> 1. setting面板的设置只有当用户去了设置面板后才会产生，所以程序要假设用户没有去过的时候设置默认值<br> 2. 拿到[NSUserDefaultsstandardUserDefaults];取值之前要 [userDefault synchronize]<br> 3. 假如从设置面板取回的是bool值，当你用代码 &nbsp;<br><br> [userDefault boolForKey:@"mapautozoom"];<br><br> 做判断的话， 假如得到了NO, 这时你无法判断 1.是用户设置了NO 2.还是用户从来没设置过所以是NO<br> 这时要先用个 &nbsp;<br> if([userDefault objectForKey:@"mapautozoom"]){<br> // 进来了说明用户设置过 然后再用&nbsp; boolForKey<br> }<br><br> url encoding<br><br><br> NSString *urlString = [stringTobeEncoding&nbsp; stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];<br></span> </span> </p> 
<p>&nbsp;</p> 
<p><span style="color: #01010a;"><span style="font-family: Arial,sans-serif,Helvetica,Tahoma;">alertView<br><br> &nbsp;&nbsp;&nbsp; UIAlertView *alertView = [[UIAlertView alloc]<br><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; initWithTitle:@"Error" message:message delegate:nil<br><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cancelButtonTitle:@"OK" otherButtonTitles:nil];<br><br> &nbsp;&nbsp;&nbsp; [alertView show];<br><br> &nbsp;&nbsp;&nbsp; [alertView release];<br><br> &nbsp;&nbsp;&nbsp; [self dismissModalViewControllerAnimated:YES];<br><br><br><br><br><br> 为UI添加处理事件方法<br><br><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UIButton *rightButton = [UIButton buttonWithType:UIButtonTypeContactAdd];<br><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [rightButton addTarget:self action:@selector(showDetails:) forControlEvents:UIControlEventTouchUpInside];<br><br><br><br> 检测用户locale &nbsp;<br><br><br> //这里实际检测出的是region format设定&nbsp; 不是language设定<br><br><br> CFLocaleGetIdentifier(CFLocaleCopyCurrent())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //zh_CN<br><br> [[NSLocaleautoupdatingCurrentLocale] localeIdentifier&nbsp; //zh_CN] <br><br><br><br> 添加国际化<br><br><br> 1. 代码中使用字符串的地方 使用&nbsp; NSLocalizedString(@"keyName",@"comment")<br><br> 2. genstrings 扫描 .m 文件 ，生成&nbsp; Localizable.strings<br> 3. 在项目目录里生成en.lproj zh-Hans.lproj文件夹， 把Localizable.strings 放进去<br> 4. 把Localizable.strings添加成项目的资源文件(copy bundle resources)，确保打包的时候会被copy进去， &nbsp;<br><br><br> 程序名国际化<br><br><br> en.lproj/InfoPlist.strings 添加<br><br> CFBundleName="EnglishName";&nbsp; &nbsp;<br><br> CFBundleDisplayName="EnglishName";<br><br><br><br> Settings.bundle 国际化<br><br><br> Settings.bundle/en.lproj/Root.strings<br> "version"="Version";<br> Root.plist的 title写 version， 显示的就是Version<br><br><br><br> 剪贴板<br><br><br> 得到剪贴板<br> UIPasteboard *pasteboard=[UIPasteboard generalPasteboard];<br><br> 把一个字符串放置到剪贴板上： //用户此后在输入框 粘贴的就是这个字符串<br> pasteboard.string = @"Hello World";<br><br><br> 从剪贴板获取字符串：<br> UIPasteboard *pasteboard=[UIPasteboard generalPasteboard]; &nbsp;<br> NSString *myString=pasteboard.string; <br><br><br><br> UISegmentedControl<br><br><br> 绑定&nbsp; value changed&nbsp; 事件<br><br><br><br><br> long press事件<br><br><br> &nbsp;&nbsp;&nbsp; UILongPressGestureRecognizer *lpress = [[UILongPressGestureRecognizeralloc] initWithTarget:selfaction:@selector(longPress:)];<br> &nbsp;&nbsp;&nbsp; lpress.minimumPressDuration = 0.5;//按0.5秒响应longPress方法<br> &nbsp;&nbsp;&nbsp; lpress.allowableMovement = 10.0;<br> &nbsp;&nbsp;&nbsp; [mapaddGestureRecognizer:lpress];//m_mapView是MKMapView的实例<br> &nbsp;&nbsp;&nbsp; [lpress release];<br><br><br><br> - (void)longPress:(UIGestureRecognizer*)gestureRecognizer<br> {<br><br><br> &nbsp;&nbsp;&nbsp; if (gestureRecognizer.state == UIGestureRecognizerStateEnded){<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // put your logic here which executed when the user release their finger<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br> &nbsp;&nbsp;&nbsp; }<br> &nbsp;&nbsp; &nbsp;<br><br><br><br><br><br><br> modal 窗口<br><br><br> MainVC.m<br> - (IBAction) helpButtonClick:(id)sender{<br> &nbsp;&nbsp;&nbsp; HelpVC *help= [[[HelpVCalloc]init] autorelease];<br> &nbsp;&nbsp;&nbsp; help.modalTransitionStyle = UIModalTransitionStyleFlipHorizontal;<br> &nbsp;&nbsp;&nbsp; help.delegate = self;<br> &nbsp;&nbsp;&nbsp; [selfpresentModalViewController:help animated:YES];<br> &nbsp;&nbsp; &nbsp;<br> &nbsp;&nbsp; &nbsp;<br> }<br><br><br> - (void)dismissModal:(HelpVC *)helpVC{<br> &nbsp;&nbsp;&nbsp; [selfdismissModalViewControllerAnimated:YES];<br> }<br><br><br><br><br><br> HelpVC.h<br><br><br> #import &lt;UIKit/UIKit.h&gt;<br><br><br> @classHelpVC;<br><br><br> @protocol HelpVCDelegate <br><br><br> - (void)dismissModal:(HelpVC *)helpVC;<br><br><br> @end<br><br><br><br><br> @interface HelpVC : UIViewController {<br> &nbsp;&nbsp; &nbsp;<br> }<br><br><br> @property (nonatomic, assign)&nbsp; id&lt;HelpVCDelegate&gt; delegate;<br><br><br> - (IBAction) closeClick:(id)sender;<br><br><br> @end<br><br><br><br> HelpVC.m<br> - (IBAction) closeClick:(id)sender{<br> &nbsp;&nbsp;&nbsp; [delegatedismissModal:self];<br> }<br><br><br><br><br><br><br></span> </span> </p>